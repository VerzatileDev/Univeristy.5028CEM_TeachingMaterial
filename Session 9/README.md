# Session 9 - Animated water tutorial

#### Table of Contents
1. [Procedural generation introduction](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/tree/master/Session%209#Procedural-generation-introduction)
2. [Third person camera](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/tree/master/Session%209#Third-person-camera)
3. [Home work](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/tree/master/Session%209#Home-work)

Welcome to Week 9! 

> In this week, we will learn how to create a procedurally generated water animation.

## Procedural generation introduction

Procedural generation is a method of creating data algorithmically. In video games, it is used to automatically create large amounts of content in a game. 
Depending on the implementation, advantages of procedural generation can include smaller file sizes, larger amounts of content, and 
randomness for less predictable gameplay.

How does procedurally generated water animationwater animation work? 

We will use combination of cos and sin functions (both are periodic functions) to generate water waves. such as

```C++
y = sin(x+t) - cos(z+t);
```

Here is x,y,z are 3D coordinates. t is the time value generated by c++ program.

The sin or cos function generates periodic wave.

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/cos.png)

We are going to use both cos and sin functions to modify the height value of water mesh to generate wave.  
 
Waves are animated using the changing time value.

To render using instancing many times,


### Implementation

* Download the base project (waterEx.zip). Always to Compile option to "x64".  Open waterEx.cpp

There is a water OBJ file already in the project folder and it has been imported into the project.

You need to add water texture and replace the existing one (sky texture) on the water plane.

* There is a water.bmp in the Textures folder. Following the previous intructions to add it into the project.

* Add water texture into fragment shader and assign it to water mesh

It should look this

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/waterTex.JPG)


### Modify water mesh in vertex shader

* Add a time variable (global) in waterEx.cpp

```C++
static float waveTime = 0;
```

* In drawscene function, update the waveTime value and send it to the shader

```C++
   // Water settings
   waveTime += 0.004f;
   glUniform1f(glGetUniformLocation(programId, "waveTime"), waveTime);
```

* Add waveTime in vertex shader

```C++
uniform float waveTime;
```

* Update water mesh Y coordinates

```C++
    if (object == WATER)
    {
      coords = vec4(objCoords, 1.0f);
      coords.y += 1.5f * (sin(coords.x + waveTime) + cos(coords.z + waveTime)) + 15.0f;
      normalExport = objNormals;
      texCoordsExport = objTexCoords;
    }
```


* Compile and run

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/waterAnim.JPG)

* Add transparency

Add following codes to the end of setup function in WaterEx.cpp to enable Alpha blending

```C++
   //Enable blending
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
```

Set Alpha value in fragment shader

```C++
   if (object == WATER) {
    colorsOut = waterTexColor;
    colorsOut.a = 0.4f;
   } 
```

* Compile and run


 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/waterTrans.JPG)

## Third person camera

A third-person camera is the camera following the player at a fixed distance or an adjustable distance. 
The eye position of OpenGL camera is set a position behind and above the player.
The center position of OpenGL camera is set a position in the center of the player.

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/Camera.JPG)

* Add eye and center vector definition of OpenGL camera.

```C++
static vec3 eye = vec3(0.0, 10.0, 15.0);
static vec3 cen = vec3(0.0, 10.0, 0.0);
```

* Add eye and center vector updating in animation function

```C++
void animate() 
{
	zVal = zVal - 0.2;
	xVal += 0.1;
	if (zVal < -25.0) zVal = 0.0;
	if (xVal > 12.0) xVal = -12.0;
	testSphere.SetPosition(vec3(0, 0, zVal)); //modify sphere's position
	Hover.SetPosition(vec3(xVal, 0, 0));

	//set camera positions
	cen = vec3(0, 0, zVal);
	eye = vec3(0, 7.0, zVal+15.0);

	// refresh screen 
	glutPostRedisplay();
}
```

* replace the camera setup with eye and center vector in draw functions

```C++
   // Calculate and update modelview matrix.
   modelViewMat = mat4(1.0);
   modelViewMat = lookAt(eye, cen, vec3(0.0, 1.0, 0.0));
   glUniformMatrix4fv(modelViewMatLoc, 1, GL_FALSE, value_ptr(modelViewMat)); 

   // Draw field 
```

* compile and take a look

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/Camera1.JPG)
 
 Notice that hovercraft, sphere and water all disappeared. That is because we have not set modelview (created by eye and center vectors) to those objects).
 
 * Change modelview calculation inside Model class
 
 Change updateModelMatrix definition in header file
 
```C++
void updateModelMatrix(unsigned int, vec3,vec3,float,float);
```

Change updateModelMatrix definition in C++ file 

```C++
void Model::updateModelMatrix(unsigned int modelViewMatLoc,vec3 eye, vec3 cen,float scale,float ZPos)
{
	ModelMatrix = mat4(1.0);
	ModelMatrix = lookAt(eye, cen, vec3(0.0, 1.0, 0.0)); //camera matrix, apply first
	ModelMatrix = glm::scale(ModelMatrix, vec3(scale, scale, scale));  //scale down the model
	ModelMatrix = glm::translate(ModelMatrix, vec3(0.0f, 0.0f, ZPos));
	ModelMatrix = glm::translate(ModelMatrix, GetPosition());
	glUniformMatrix4fv(modelViewMatLoc, 1, GL_FALSE, value_ptr(ModelMatrix));  //send modelview matrix to the shader
}
```

* Update codes used in DrawScene function WaterEx.cpp

```C++
   // Draw water
   Water.updateModelMatrix(modelViewMatLoc, eye, cen, 0.2f,-60.0f);
   glUniform1ui(objectLoc, WATER);  //if (object == WATER)
   Water.Draw();
   
   // Draw Hover
   Hover.updateModelMatrix(modelViewMatLoc, eye, cen, 1.5f, 0.0f);
   glUniform1ui(objectLoc, HOVER);  //if (object == HOVER)
   Hover.Draw();
```

* Change modelview calculation inside Sphere class 

Use similar method as Model class to change ModelView codes

* Finally, the camera should follow the moving sphere.

 ![Tex1 picture](https://github.coventry.ac.uk/ac7020/212CR_TeachingMaterial/blob/master/Session%209/Readme%20Pictures/Camera2.JPG)
 
* Animated third person camera (Optional)

Add some animation to the third person camera. For example, base on the acceleration and deacceleration of the player, 
increase or decrease the distance between camera and player.


## Home work

Continue to work on your own project (optional)

* Create a terrain model in 3DS max and import into project (replace field).

* Add animated water mesh 





